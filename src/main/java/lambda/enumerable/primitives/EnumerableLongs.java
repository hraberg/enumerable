package lambda.enumerable.primitives;

import static java.lang.System.*;

import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Comparator;

import lambda.enumerable.Enumerable;
import lambda.enumerable.collection.EList;
import lambda.enumerable.collection.ESet;
import lambda.primitives.Fn1LtoB;
import lambda.primitives.Fn1LtoD;
import lambda.primitives.Fn1LtoI;
import lambda.primitives.Fn1LtoL;
import lambda.primitives.Fn1LtoO;
import lambda.primitives.Fn2LLtoL;
import lambda.primitives.Fn2LLtoO;

/**
 * Ruby/Smalltalk style internal iterators for Java 5 using bytecode
 * transformation to capture expressions as closures.
 * 
 * <p>
 * <a href="http: * module in 1.8.6</a>
 * </p>
 * <i>This file was generated by
 * lambda.enumerable.primitives.PrimitiveEnumerableGenerator from
 * EnumerableDoubles.java.</i>
 */
public class EnumerableLongs {
    /**
     * Passes each element of the array to the given block. The method returns
     * true if the block never returns false.
     */
    public static <E> boolean all(long[] array, Fn1LtoB block) {
        for (long each : array)
            if (!block.call(each))
                return false;
        return true;
    }

    /**
     * Passes each element of the array to the given block. The method returns
     * true if the block ever returns a value other than false.
     */
    public static <E> boolean any(long[] array, Fn1LtoB block) {
        for (long each : array)
            if (block.call(each))
                return true;
        return false;
    }

    /**
     * Returns a new list with the results of running block once for every
     * element in array.
     */
    public static <R> Object[] collect(long[] array, Fn1LtoO<R> block) {
        Object[] result = new Object[array.length];
        int i = 0;
        for (long each : array)
            result[i++] = block.call(each);
        return result;
    }

    /**
     * @see #collect(long[], Fn1LtoO)
     */
    public static/* don't change */double[] collect(long[] array, Fn1LtoD block) {
        /* don't change */double[] result = new /* don't change */double[array.length];
        int i = 0;
        for (long each : array)
            result[i++] = block.call(each);
        return result;
    }

    /**
     * @see #collect(long[], Fn1LtoO)
     */
    public static int[] collect(long[] array, Fn1LtoI block) {
        int[] result = new int[array.length];
        int i = 0;
        for (long each : array)
            result[i++] = block.call(each);
        return result;
    }

    /**
     * @see #collect(long[], Fn1LtoO)
     */
    public static long[] collect(long[] array, Fn1LtoL block) {
        long[] result = new long[array.length];
        int i = 0;
        for (long each : array)
            result[i++] = block.call(each);
        return result;
    }

    /**
     * Returns a new list with the results of running block once for every
     * element in array.
     */
    @SuppressWarnings("unchecked")
    public static <R> R[] collect(long[] array, Fn1LtoO<R> block, Class<R> type) {
        R[] result = (R[]) Array.newInstance(type, array.length);
        int i = 0;
        for (long each : array)
            result[i++] = block.call(each);
        return result;
    }

    /**
     * Passes each entry in array to block. Returns the first for which block is
     * not false. If no value matches, it returns ifNone.
     */
    public static long detect(long[] array, long ifNone, Fn1LtoB block) {
        for (long each : array)
            if (block.call(each))
                return each;
        return ifNone;
    }

    /**
     * Calls block for each item in array.
     */
    public static <R> long[] each(long[] array, Fn1LtoO<R> block) {
        for (long each : array)
            block.call(each);
        return array;
    }

    /**
     * @see #each(long[], Fn1LtoO)
     */
    public static long[] each(long[] array, Fn1LtoD block) {
        for (long each : array)
            block.call(each);
        return array;
    }

    /**
     * @see #each(long[], Fn1LtoO)
     */
    public static long[] each(long[] array, Fn1LtoI block) {
        for (long each : array)
            block.call(each);
        return array;
    }

    /**
     * @see #each(long[], Fn1LtoO)
     */
    public static long[] each(long[] array, Fn1LtoL block) {
        for (long each : array)
            block.call(each);
        return array;
    }

    /**
     * @see #each(long[], Fn1LtoO)
     */
    public static long[] each(long[] array, Fn1LtoB block) {
        for (long each : array)
            block.call(each);
        return array;
    }

    /**
     * Calls block with two arguments, the item and its index, for each item in
     * array.
     */
    public static <R> long[] eachWithIndex(long[] array, Fn2LLtoO<R> block) {
        long idx = 0;
        for (long each : array)
            block.call(each, idx++);
        return array;
    }

    /**
     * @see #eachWithIndex(long[], Fn2LLtoO)
     */
    public static long[] eachWithIndex(long[] array, Fn2LLtoL block) {
        long idx = 0;
        for (long each : array)
            block.call(each, idx++);
        return array;
    }

    /**
     * @see #toList(long[])
     */
    public static <E> EList<Long> entries(long[] array) {
        return toList(array);
    }

    /**
     * @see #detect(long[], long, Fn1LtoB)
     */
    public static long find(long[] array, long ifNone, Fn1LtoB block) {
        return detect(array, ifNone, block);
    }

    /**
     * @see #select(long[], Fn1LtoB)
     */
    public static long[] findAll(long[] array, Fn1LtoB block) {
        return select(array, block);
    }

    /**
     * Named parameter for detect.
     * 
     * @see #detect(long[], long, Fn1LtoB)
     * @see #find(long[], long, Fn1LtoB)
     */
    public static long ifNone(long defaultValue) {
        return defaultValue;
    }

    /**
     * @see #member(long[], long)
     */
    public static boolean include(long[] array, long value) {
        return member(array, value);
    }

    /**
     * Combines the elements of array by applying the block to an accumulator
     * value (memo) and each element in turn. At each step, memo is set to the
     * value returned by the block. This form uses the first element of the
     * array as a the initial value (and skips that element while iterating).
     */
    public static long inject(long[] array, Fn2LLtoL block) {
        long initial = array[0];
        for (int i = 1; i < array.length; i++)
            initial = block.call(initial, array[i]);
        return initial;
    }

    /**
     * Combines the elements of array by applying the block to an accumulator
     * value (memo) and each element in turn. At each step, memo is set to the
     * value returned by the block. This form lets you supply an initial value
     * for memo.
     */
    public static long inject(long[] array, long initial, Fn2LLtoL block) {
        for (long each : array)
            initial = block.call(initial, each);
        return initial;
    }

    /**
     * @see #collect(long[], Fn1LtoO)
     */
    public static <R> Object[] map(long[] array, Fn1LtoO<R> block) {
        return collect(array, block);
    }

    /**
     * @see #collect(long[], Fn1LtoO)
     */
    public static/* don't change */double[] map(long[] array, Fn1LtoD block) {
        return collect(array, block);
    }

    /**
     * @see #collect(long[], Fn1LtoO)
     */
    public static int[] map(long[] array, Fn1LtoI block) {
        return collect(array, block);
    }

    /**
     * @see #collect(long[], Fn1LtoO)
     */
    public static long[] map(long[] array, Fn1LtoL block) {
        return collect(array, block);
    }

    /**
     * @see #collect(long[], Fn1LtoO, Class)
     */
    public static <R> R[] map(long[] array, Fn1LtoO<R> block, Class<R> type) {
        return collect(array, block, type);
    }

    /**
     * Returns the maximum value in array.
     */
    public static long max(long[] array) {
        return min(array, new ReverseNaturalOrderLongComparator(new NaturalOrderPrimitiveComparator()));
    }

    /**
     * Returns the maximum value in array. This form uses the block to
     * {@link Comparator#compare}.
     */
    public static long max(long[] array, Fn2LLtoL block) {
        return min(array, new ReverseNaturalOrderLongComparator(new BlockLongComparator(block)));
    }

    /**
     * Returns true if any member of array equals value. Equality is tested
     * using {@link Object#equals(Object)}.
     */
    public static boolean member(long[] array, long value) {
        return Arrays.binarySearch(sort(array), value) >= 0;
    }

    /**
     * Returns the minimum value in array.
     */
    public static long min(long[] array) {
        return min(array, new NaturalOrderPrimitiveComparator());
    }

    /**
     * Returns the minimum value in array. This form uses the block to
     * {@link Comparator#compare}.
     */
    public static long min(long[] array, Fn2LLtoL block) {
        return min(array, new BlockLongComparator(block));
    }

    /**
     * Returns two lists, the first containing the elements of array for which
     * the block evaluates to true, the second containing the rest.
     */
    public static long[][] partition(long[] array, Fn1LtoB block) {
        long[][] result = new long[2][];

        result[0] = select(array, block);
        result[1] = reject(array, block);

        return result;
    }

    /**
     * Returns an array containing all elements of array for which block is
     * false.
     */
    public static long[] reject(long[] array, Fn1LtoB block) {
        return selectOrReject(array, block, false);
    }

    /**
     * Returns an array containing all elements of array for which block is not
     * false.
     */
    public static long[] select(long[] array, Fn1LtoB block) {
        return selectOrReject(array, block, true);
    }

    private static long[] selectOrReject(long[] array, Fn1LtoB block, boolean select) {
        long[] result = new long[array.length];
        int i = 0;
        for (long each : array)
            if (block.call(each) == select)
                result[i++] = each;
        return copy(result, i);
    }

    /**
     * Returns an array containing the items in array sorted, according to their
     * own compareTo method.
     */
    public static long[] sort(long[] array) {
        long[] result = copy(array, array.length);
        Arrays.sort(result);
        return result;
    }

    /**
     * Returns a list containing the items in array.
     */
    public static EList<Long> toList(long[] array) {
        EList<Long> result = new EList<Long>(array.length);
        for (long each : array)
            result.add(each);
        return result;
    }

    /**
     * Creates a new Set containing the elements of the given array.
     */
    public static ESet<Long> toSet(long[] array) {
        return Enumerable.toSet(toList(array));
    }

    /**
     * Creates a new Set containing the elements of the given array, the
     * elements are preprocessed by the given block.
     */
    public static <R> ESet<R> toSet(long[] array, Fn1LtoO<R> block) {
        return Enumerable.toSet(toList(array), block);
    }

    static long min(long[] array, LongComparator comparator) {
        long result = array[0];
        for (int i = 1; i < array.length; i++) {
            long each = array[i];
            if (comparator.compare(each, result) < 0)
                result = each;
        }
        return result;
    }

    static interface LongComparator {
        int compare(long a, long b);
    }

    static class NaturalOrderPrimitiveComparator implements LongComparator {
        public int compare(/* don't change */double a, /* don't change */double b) {
            return /* don't change */Double.compare(a, b);
        }

        public int compare(long a, long b) {
            return (a < b) ? -1 : ((a > b) ? 1 : 0);
        }

        public int compare(int a, int b) {
            return (a < b) ? -1 : ((a > b) ? 1 : 0);
        }
    }

    static class BlockLongComparator implements LongComparator {
        Fn2LLtoL block;

        BlockLongComparator(Fn2LLtoL block) {
            this.block = block;
        }

        public int compare(long a, long b) {
            return (int) block.call(a, b);
        }
    }

    static class ReverseNaturalOrderLongComparator implements LongComparator {
        LongComparator comparator;

        ReverseNaturalOrderLongComparator(LongComparator comparator) {
            this.comparator = comparator;
        }

        public int compare(long a, long b) {
            return -comparator.compare(a, b);
        }
    }

    static long[] copy(long[] array, int length) {
        long[] result = new long[length];
        arraycopy(array, 0, result, 0, length);
        return result;
    }
}
